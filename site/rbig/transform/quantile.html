<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.1" />
<title>rbig.transform.quantile API documentation</title>
<meta name="description" content="" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>rbig.transform.quantile</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import warnings
from typing import Optional

import numpy as np
from scipy import stats
from scipy.interpolate import interp1d
from sklearn.preprocessing import minmax_scale
from sklearn.utils import check_array, check_random_state

from rbig.transform.base import DensityMixin, BaseTransform

BOUNDS_THRESHHOLD = 1e-7


class QuantileTransformer(BaseTransform, DensityMixin):
    pass


class QuantileTransformerOld(BaseTransform, DensityMixin):
    def __init__(
        self,
        n_quantiles: int = 1_000,
        bin_est: Optional[str] = None,
        subsample: int = 1_000,
        random_state: int = 123,
        support_ext: float = 10,
        interp: str = &#34;linear&#34;,
    ) -&gt; None:
        self.n_quantiles = n_quantiles
        self.bin_est = bin_est
        self.subsample = subsample
        self.random_state = random_state
        self.support_ext = support_ext
        self.interp = interp

    def fit(self, X: np.ndarray, y: Optional[np.ndarray] = None):

        # check n_quantiles is valid
        if self.n_quantiles &lt;= 0:
            raise ValueError(
                f&#34;Invalid n_quantiles: {self.n_quantiles}&#34;
                &#34;The number of quantiles must be at least 1.&#34;
            )

        # check n_subsamples is valid
        if self.subsample &lt;= 0:
            raise ValueError(
                f&#34;Invalid number of subsamples: {self.subsample}&#34;
                &#34;The number of quantiles must be at least 1.&#34;
            )

        # check that n_quantiles &gt; subsamples
        if self.n_quantiles &gt; self.subsample:
            raise ValueError(
                f&#34;The n_quanties &#39;{self.n_quantiles}&#39; must not be greater than &#34;
                f&#34;subsamples: &#39;{self.subsample}&#39;.&#34;
            )

        # check inputs X
        X = check_array(X, copy=False)

        n_samples, self.d_dimensions = X.shape

        # check n_quantiles &gt; n_samples
        if self.n_quantiles &gt; n_samples:
            warnings.warn(
                f&#34;n_quantiles &#39;{self.n_quantiles}&#39; is greater than total &#34;
                f&#34;number of samples &#39;{n_samples}&#39;. Setting to n_samples.&#34;
            )

        self.n_quantiles_ = max(1, min(self.n_quantiles, n_samples))

        # initialize random state
        rng = check_random_state(self.random_state)

        self._fit(X, rng)

        return self

    def _fit(self, X, random_state):

        # dimensions of data
        n_samples, n_features = X.shape

        self.quantiles_ = []
        self.references_ = []
        for ifeature in X.T:
            if self.subsample &lt; n_samples:
                subsample_idx = random_state.choice(
                    n_samples, size=self.subsample, replace=False
                )

                ifeature = ifeature.take(subsample_idx, mode=&#34;clip&#34;)

            # create the quantiles reference for each feature
            if self.bin_est is None:
                references = np.linspace(
                    0, 1, self.n_quantiles_, endpoint=True
                )
            else:
                references = np.histogram_bin_edges(
                    ifeature, bins=self.bin_est, range=(0, 1)
                )
            # save quantiles
            quantiles = np.nanpercentile(ifeature, references * 100)
            self.quantiles_.append(quantiles)

            # save references
            self.references_.append(references)

        # extend support
        if self.support_ext != 0.0:

            for idx, ifeature in enumerate(X.T):

                # Extend the support
                new_reference, new_quantiles = self.extend_support(
                    self.references_[idx],
                    self.quantiles_[idx],
                    self.support_ext,
                )

                self.quantiles_[idx] = new_quantiles
                self.references_[idx] = new_reference

        return self

    def extend_support(self, references, quantiles, support_extension):
        # Extend Support
        new_reference = np.hstack(
            [-support_extension / 100, references, 1 + support_extension / 100]
        )

        # extrapolate
        new_quantiles = interp1d(
            references,
            quantiles,
            kind=self.interp,
            fill_value=&#34;extrapolate&#34;,
            axis=0,
        )(new_reference)

        # scale new
        reference_scale = minmax_scale(new_reference, axis=0)

        # Put back in original domain
        new_quantiles = interp1d(
            new_reference,
            new_quantiles,
            kind=self.interp,
            fill_value=&#34;extrapolate&#34;,
            axis=0,
        )(reference_scale)

        return reference_scale, new_quantiles

    def transform(self, X, y=None):
        X = check_array(X, copy=True)
        X = self._transform(X, inverse=False)
        return X

    def inverse_transform(self, X, y=None):
        X = check_array(X, copy=True)
        X = self._transform(X, inverse=True)
        return X

    def _transform(self, X, inverse=False):
        for feature_idx in range(X.shape[1]):
            X[:, feature_idx] = self.transform_col(
                X[:, feature_idx],
                self.quantiles_[feature_idx],
                self.references_[feature_idx],
                inverse=inverse,
            )
        return X

    def transform_col(self, X_col, quantiles, references, inverse):

        if not inverse:
            lower_bound_x = quantiles[0]
            upper_bound_x = quantiles[-1]
            lower_bound_y = 0
            upper_bound_y = 1
        else:
            lower_bound_x = 0  # CHECK: references[0]
            upper_bound_x = 1
            lower_bound_y = quantiles[0]
            upper_bound_y = quantiles[1]

            # use CDF function
            # with np.errstate(invalid=&#34;ignore&#34;):  # hide NAN comparison warnings
            X_col = stats.norm.cdf(X_col)

        # Find index for lower and higher bounds
        with np.errstate(invalid=&#34;ignore&#34;):
            lower_bounds_idx = X_col - BOUNDS_THRESHHOLD &lt; lower_bound_x
            upper_bounds_idx = X_col + BOUNDS_THRESHHOLD &gt; upper_bound_x

        isfinite_mask = ~np.isnan(X_col)
        X_col_finite = X_col[isfinite_mask]

        if not inverse:
            # Interpolate in one direction and in the other and take the
            # mean. This is in case of repeated values in the features
            # and hence repeated quantiles
            #
            # If we don&#39;t do this, only one extreme of the duplicated is
            # used (the upper when we do ascending, and the
            # lower for descending). We take the mean of these two
            X_col[isfinite_mask] = 0.5 * (
                interp1d(
                    quantiles,
                    references,
                    kind=self.interp,
                    fill_value=&#34;extrapolate&#34;,
                )(X_col_finite)
                - interp1d(
                    -quantiles[::-1],
                    -references[::-1],
                    kind=self.interp,
                    fill_value=&#34;extrapolate&#34;,
                    copy=True,
                )(-X_col_finite)
            )
            # X_col[isfinite_mask] = 0.5 * (
            #     np.interp(X_col_finite, quantiles, references)
            #     - np.interp(-X_col_finite, -quantiles[::-1], -references[::-1])
            # )
        else:
            X_col[isfinite_mask] = interp1d(
                references,
                quantiles,
                kind=self.interp,
                fill_value=&#34;extrapolate&#34;,
                copy=True,
            )(X_col_finite)
            # X_col[isfinite_mask] = np.interp(X_col_finite, references, quantiles)

        X_col[upper_bounds_idx] = upper_bound_y
        X_col[lower_bounds_idx] = lower_bound_y
        # Forward - Match Output distribution
        if not inverse:
            # with np.errstate(invalid=&#34;ignore&#34;):
            X_col = stats.norm.ppf(X_col)
            # find the value to clip the data to avoid mapping to
            # infinity. Clip such that the inverse transform will be
            # consistent
            clip_min = stats.norm.ppf(BOUNDS_THRESHHOLD - np.spacing(1))
            clip_max = stats.norm.ppf(1 - (BOUNDS_THRESHHOLD - np.spacing(1)))
            X_col = np.clip(X_col, clip_min, clip_max)
            # else output distribution is uniform and the ppf is the
            # identity function so we let X_col unchanged

        return X_col

    def score_samples(self, X, y=None):

        # transform data, invCDF(X)
        x_ = self.inverse_transform(X)

        # get - log probability, - log PDF( invCDF (x) )
        independent_log_prob = -stats.norm.logpdf(x_)

        # sum of log-likelihood is product of indepenent likelihoods
        return independent_log_prob.sum(axis=1)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="rbig.transform.quantile.QuantileTransformer"><code class="flex name class">
<span>class <span class="ident">QuantileTransformer</span></span>
</code></dt>
<dd>
<div class="desc"><p>Base class for all estimators in scikit-learn</p>
<h2 id="notes">Notes</h2>
<p>All estimators should specify all the parameters that can be set
at the class level in their <code>__init__</code> as explicit keyword
arguments (no <code>*args</code> or <code>**kwargs</code>).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class QuantileTransformer(BaseTransform, DensityMixin):
    pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="rbig.transform.base.BaseTransform" href="base.html#rbig.transform.base.BaseTransform">BaseTransform</a></li>
<li>sklearn.base.BaseEstimator</li>
<li>sklearn.base.TransformerMixin</li>
<li><a title="rbig.transform.base.DensityMixin" href="base.html#rbig.transform.base.DensityMixin">DensityMixin</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="rbig.transform.base.DensityMixin" href="base.html#rbig.transform.base.DensityMixin">DensityMixin</a></b></code>:
<ul class="hlist">
<li><code><a title="rbig.transform.base.DensityMixin.sample" href="base.html#rbig.transform.base.DensityMixin.sample">sample</a></code></li>
<li><code><a title="rbig.transform.base.DensityMixin.score" href="base.html#rbig.transform.base.DensityMixin.score">score</a></code></li>
<li><code><a title="rbig.transform.base.DensityMixin.score_samples" href="base.html#rbig.transform.base.DensityMixin.score_samples">score_samples</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="rbig.transform.quantile.QuantileTransformerOld"><code class="flex name class">
<span>class <span class="ident">QuantileTransformerOld</span></span>
<span>(</span><span>n_quantiles: int = 1000, bin_est: Union[str, NoneType] = None, subsample: int = 1000, random_state: int = 123, support_ext: float = 10, interp: str = 'linear')</span>
</code></dt>
<dd>
<div class="desc"><p>Base class for all estimators in scikit-learn</p>
<h2 id="notes">Notes</h2>
<p>All estimators should specify all the parameters that can be set
at the class level in their <code>__init__</code> as explicit keyword
arguments (no <code>*args</code> or <code>**kwargs</code>).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class QuantileTransformerOld(BaseTransform, DensityMixin):
    def __init__(
        self,
        n_quantiles: int = 1_000,
        bin_est: Optional[str] = None,
        subsample: int = 1_000,
        random_state: int = 123,
        support_ext: float = 10,
        interp: str = &#34;linear&#34;,
    ) -&gt; None:
        self.n_quantiles = n_quantiles
        self.bin_est = bin_est
        self.subsample = subsample
        self.random_state = random_state
        self.support_ext = support_ext
        self.interp = interp

    def fit(self, X: np.ndarray, y: Optional[np.ndarray] = None):

        # check n_quantiles is valid
        if self.n_quantiles &lt;= 0:
            raise ValueError(
                f&#34;Invalid n_quantiles: {self.n_quantiles}&#34;
                &#34;The number of quantiles must be at least 1.&#34;
            )

        # check n_subsamples is valid
        if self.subsample &lt;= 0:
            raise ValueError(
                f&#34;Invalid number of subsamples: {self.subsample}&#34;
                &#34;The number of quantiles must be at least 1.&#34;
            )

        # check that n_quantiles &gt; subsamples
        if self.n_quantiles &gt; self.subsample:
            raise ValueError(
                f&#34;The n_quanties &#39;{self.n_quantiles}&#39; must not be greater than &#34;
                f&#34;subsamples: &#39;{self.subsample}&#39;.&#34;
            )

        # check inputs X
        X = check_array(X, copy=False)

        n_samples, self.d_dimensions = X.shape

        # check n_quantiles &gt; n_samples
        if self.n_quantiles &gt; n_samples:
            warnings.warn(
                f&#34;n_quantiles &#39;{self.n_quantiles}&#39; is greater than total &#34;
                f&#34;number of samples &#39;{n_samples}&#39;. Setting to n_samples.&#34;
            )

        self.n_quantiles_ = max(1, min(self.n_quantiles, n_samples))

        # initialize random state
        rng = check_random_state(self.random_state)

        self._fit(X, rng)

        return self

    def _fit(self, X, random_state):

        # dimensions of data
        n_samples, n_features = X.shape

        self.quantiles_ = []
        self.references_ = []
        for ifeature in X.T:
            if self.subsample &lt; n_samples:
                subsample_idx = random_state.choice(
                    n_samples, size=self.subsample, replace=False
                )

                ifeature = ifeature.take(subsample_idx, mode=&#34;clip&#34;)

            # create the quantiles reference for each feature
            if self.bin_est is None:
                references = np.linspace(
                    0, 1, self.n_quantiles_, endpoint=True
                )
            else:
                references = np.histogram_bin_edges(
                    ifeature, bins=self.bin_est, range=(0, 1)
                )
            # save quantiles
            quantiles = np.nanpercentile(ifeature, references * 100)
            self.quantiles_.append(quantiles)

            # save references
            self.references_.append(references)

        # extend support
        if self.support_ext != 0.0:

            for idx, ifeature in enumerate(X.T):

                # Extend the support
                new_reference, new_quantiles = self.extend_support(
                    self.references_[idx],
                    self.quantiles_[idx],
                    self.support_ext,
                )

                self.quantiles_[idx] = new_quantiles
                self.references_[idx] = new_reference

        return self

    def extend_support(self, references, quantiles, support_extension):
        # Extend Support
        new_reference = np.hstack(
            [-support_extension / 100, references, 1 + support_extension / 100]
        )

        # extrapolate
        new_quantiles = interp1d(
            references,
            quantiles,
            kind=self.interp,
            fill_value=&#34;extrapolate&#34;,
            axis=0,
        )(new_reference)

        # scale new
        reference_scale = minmax_scale(new_reference, axis=0)

        # Put back in original domain
        new_quantiles = interp1d(
            new_reference,
            new_quantiles,
            kind=self.interp,
            fill_value=&#34;extrapolate&#34;,
            axis=0,
        )(reference_scale)

        return reference_scale, new_quantiles

    def transform(self, X, y=None):
        X = check_array(X, copy=True)
        X = self._transform(X, inverse=False)
        return X

    def inverse_transform(self, X, y=None):
        X = check_array(X, copy=True)
        X = self._transform(X, inverse=True)
        return X

    def _transform(self, X, inverse=False):
        for feature_idx in range(X.shape[1]):
            X[:, feature_idx] = self.transform_col(
                X[:, feature_idx],
                self.quantiles_[feature_idx],
                self.references_[feature_idx],
                inverse=inverse,
            )
        return X

    def transform_col(self, X_col, quantiles, references, inverse):

        if not inverse:
            lower_bound_x = quantiles[0]
            upper_bound_x = quantiles[-1]
            lower_bound_y = 0
            upper_bound_y = 1
        else:
            lower_bound_x = 0  # CHECK: references[0]
            upper_bound_x = 1
            lower_bound_y = quantiles[0]
            upper_bound_y = quantiles[1]

            # use CDF function
            # with np.errstate(invalid=&#34;ignore&#34;):  # hide NAN comparison warnings
            X_col = stats.norm.cdf(X_col)

        # Find index for lower and higher bounds
        with np.errstate(invalid=&#34;ignore&#34;):
            lower_bounds_idx = X_col - BOUNDS_THRESHHOLD &lt; lower_bound_x
            upper_bounds_idx = X_col + BOUNDS_THRESHHOLD &gt; upper_bound_x

        isfinite_mask = ~np.isnan(X_col)
        X_col_finite = X_col[isfinite_mask]

        if not inverse:
            # Interpolate in one direction and in the other and take the
            # mean. This is in case of repeated values in the features
            # and hence repeated quantiles
            #
            # If we don&#39;t do this, only one extreme of the duplicated is
            # used (the upper when we do ascending, and the
            # lower for descending). We take the mean of these two
            X_col[isfinite_mask] = 0.5 * (
                interp1d(
                    quantiles,
                    references,
                    kind=self.interp,
                    fill_value=&#34;extrapolate&#34;,
                )(X_col_finite)
                - interp1d(
                    -quantiles[::-1],
                    -references[::-1],
                    kind=self.interp,
                    fill_value=&#34;extrapolate&#34;,
                    copy=True,
                )(-X_col_finite)
            )
            # X_col[isfinite_mask] = 0.5 * (
            #     np.interp(X_col_finite, quantiles, references)
            #     - np.interp(-X_col_finite, -quantiles[::-1], -references[::-1])
            # )
        else:
            X_col[isfinite_mask] = interp1d(
                references,
                quantiles,
                kind=self.interp,
                fill_value=&#34;extrapolate&#34;,
                copy=True,
            )(X_col_finite)
            # X_col[isfinite_mask] = np.interp(X_col_finite, references, quantiles)

        X_col[upper_bounds_idx] = upper_bound_y
        X_col[lower_bounds_idx] = lower_bound_y
        # Forward - Match Output distribution
        if not inverse:
            # with np.errstate(invalid=&#34;ignore&#34;):
            X_col = stats.norm.ppf(X_col)
            # find the value to clip the data to avoid mapping to
            # infinity. Clip such that the inverse transform will be
            # consistent
            clip_min = stats.norm.ppf(BOUNDS_THRESHHOLD - np.spacing(1))
            clip_max = stats.norm.ppf(1 - (BOUNDS_THRESHHOLD - np.spacing(1)))
            X_col = np.clip(X_col, clip_min, clip_max)
            # else output distribution is uniform and the ppf is the
            # identity function so we let X_col unchanged

        return X_col

    def score_samples(self, X, y=None):

        # transform data, invCDF(X)
        x_ = self.inverse_transform(X)

        # get - log probability, - log PDF( invCDF (x) )
        independent_log_prob = -stats.norm.logpdf(x_)

        # sum of log-likelihood is product of indepenent likelihoods
        return independent_log_prob.sum(axis=1)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="rbig.transform.base.BaseTransform" href="base.html#rbig.transform.base.BaseTransform">BaseTransform</a></li>
<li>sklearn.base.BaseEstimator</li>
<li>sklearn.base.TransformerMixin</li>
<li><a title="rbig.transform.base.DensityMixin" href="base.html#rbig.transform.base.DensityMixin">DensityMixin</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="rbig.transform.quantile.QuantileTransformerOld.extend_support"><code class="name flex">
<span>def <span class="ident">extend_support</span></span>(<span>self, references, quantiles, support_extension)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def extend_support(self, references, quantiles, support_extension):
    # Extend Support
    new_reference = np.hstack(
        [-support_extension / 100, references, 1 + support_extension / 100]
    )

    # extrapolate
    new_quantiles = interp1d(
        references,
        quantiles,
        kind=self.interp,
        fill_value=&#34;extrapolate&#34;,
        axis=0,
    )(new_reference)

    # scale new
    reference_scale = minmax_scale(new_reference, axis=0)

    # Put back in original domain
    new_quantiles = interp1d(
        new_reference,
        new_quantiles,
        kind=self.interp,
        fill_value=&#34;extrapolate&#34;,
        axis=0,
    )(reference_scale)

    return reference_scale, new_quantiles</code></pre>
</details>
</dd>
<dt id="rbig.transform.quantile.QuantileTransformerOld.fit"><code class="name flex">
<span>def <span class="ident">fit</span></span>(<span>self, X: numpy.ndarray, y: Union[numpy.ndarray, NoneType] = None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fit(self, X: np.ndarray, y: Optional[np.ndarray] = None):

    # check n_quantiles is valid
    if self.n_quantiles &lt;= 0:
        raise ValueError(
            f&#34;Invalid n_quantiles: {self.n_quantiles}&#34;
            &#34;The number of quantiles must be at least 1.&#34;
        )

    # check n_subsamples is valid
    if self.subsample &lt;= 0:
        raise ValueError(
            f&#34;Invalid number of subsamples: {self.subsample}&#34;
            &#34;The number of quantiles must be at least 1.&#34;
        )

    # check that n_quantiles &gt; subsamples
    if self.n_quantiles &gt; self.subsample:
        raise ValueError(
            f&#34;The n_quanties &#39;{self.n_quantiles}&#39; must not be greater than &#34;
            f&#34;subsamples: &#39;{self.subsample}&#39;.&#34;
        )

    # check inputs X
    X = check_array(X, copy=False)

    n_samples, self.d_dimensions = X.shape

    # check n_quantiles &gt; n_samples
    if self.n_quantiles &gt; n_samples:
        warnings.warn(
            f&#34;n_quantiles &#39;{self.n_quantiles}&#39; is greater than total &#34;
            f&#34;number of samples &#39;{n_samples}&#39;. Setting to n_samples.&#34;
        )

    self.n_quantiles_ = max(1, min(self.n_quantiles, n_samples))

    # initialize random state
    rng = check_random_state(self.random_state)

    self._fit(X, rng)

    return self</code></pre>
</details>
</dd>
<dt id="rbig.transform.quantile.QuantileTransformerOld.inverse_transform"><code class="name flex">
<span>def <span class="ident">inverse_transform</span></span>(<span>self, X, y=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def inverse_transform(self, X, y=None):
    X = check_array(X, copy=True)
    X = self._transform(X, inverse=True)
    return X</code></pre>
</details>
</dd>
<dt id="rbig.transform.quantile.QuantileTransformerOld.transform"><code class="name flex">
<span>def <span class="ident">transform</span></span>(<span>self, X, y=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def transform(self, X, y=None):
    X = check_array(X, copy=True)
    X = self._transform(X, inverse=False)
    return X</code></pre>
</details>
</dd>
<dt id="rbig.transform.quantile.QuantileTransformerOld.transform_col"><code class="name flex">
<span>def <span class="ident">transform_col</span></span>(<span>self, X_col, quantiles, references, inverse)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def transform_col(self, X_col, quantiles, references, inverse):

    if not inverse:
        lower_bound_x = quantiles[0]
        upper_bound_x = quantiles[-1]
        lower_bound_y = 0
        upper_bound_y = 1
    else:
        lower_bound_x = 0  # CHECK: references[0]
        upper_bound_x = 1
        lower_bound_y = quantiles[0]
        upper_bound_y = quantiles[1]

        # use CDF function
        # with np.errstate(invalid=&#34;ignore&#34;):  # hide NAN comparison warnings
        X_col = stats.norm.cdf(X_col)

    # Find index for lower and higher bounds
    with np.errstate(invalid=&#34;ignore&#34;):
        lower_bounds_idx = X_col - BOUNDS_THRESHHOLD &lt; lower_bound_x
        upper_bounds_idx = X_col + BOUNDS_THRESHHOLD &gt; upper_bound_x

    isfinite_mask = ~np.isnan(X_col)
    X_col_finite = X_col[isfinite_mask]

    if not inverse:
        # Interpolate in one direction and in the other and take the
        # mean. This is in case of repeated values in the features
        # and hence repeated quantiles
        #
        # If we don&#39;t do this, only one extreme of the duplicated is
        # used (the upper when we do ascending, and the
        # lower for descending). We take the mean of these two
        X_col[isfinite_mask] = 0.5 * (
            interp1d(
                quantiles,
                references,
                kind=self.interp,
                fill_value=&#34;extrapolate&#34;,
            )(X_col_finite)
            - interp1d(
                -quantiles[::-1],
                -references[::-1],
                kind=self.interp,
                fill_value=&#34;extrapolate&#34;,
                copy=True,
            )(-X_col_finite)
        )
        # X_col[isfinite_mask] = 0.5 * (
        #     np.interp(X_col_finite, quantiles, references)
        #     - np.interp(-X_col_finite, -quantiles[::-1], -references[::-1])
        # )
    else:
        X_col[isfinite_mask] = interp1d(
            references,
            quantiles,
            kind=self.interp,
            fill_value=&#34;extrapolate&#34;,
            copy=True,
        )(X_col_finite)
        # X_col[isfinite_mask] = np.interp(X_col_finite, references, quantiles)

    X_col[upper_bounds_idx] = upper_bound_y
    X_col[lower_bounds_idx] = lower_bound_y
    # Forward - Match Output distribution
    if not inverse:
        # with np.errstate(invalid=&#34;ignore&#34;):
        X_col = stats.norm.ppf(X_col)
        # find the value to clip the data to avoid mapping to
        # infinity. Clip such that the inverse transform will be
        # consistent
        clip_min = stats.norm.ppf(BOUNDS_THRESHHOLD - np.spacing(1))
        clip_max = stats.norm.ppf(1 - (BOUNDS_THRESHHOLD - np.spacing(1)))
        X_col = np.clip(X_col, clip_min, clip_max)
        # else output distribution is uniform and the ppf is the
        # identity function so we let X_col unchanged

    return X_col</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="rbig.transform.base.DensityMixin" href="base.html#rbig.transform.base.DensityMixin">DensityMixin</a></b></code>:
<ul class="hlist">
<li><code><a title="rbig.transform.base.DensityMixin.sample" href="base.html#rbig.transform.base.DensityMixin.sample">sample</a></code></li>
<li><code><a title="rbig.transform.base.DensityMixin.score" href="base.html#rbig.transform.base.DensityMixin.score">score</a></code></li>
<li><code><a title="rbig.transform.base.DensityMixin.score_samples" href="base.html#rbig.transform.base.DensityMixin.score_samples">score_samples</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="rbig.transform" href="index.html">rbig.transform</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="rbig.transform.quantile.QuantileTransformer" href="#rbig.transform.quantile.QuantileTransformer">QuantileTransformer</a></code></h4>
</li>
<li>
<h4><code><a title="rbig.transform.quantile.QuantileTransformerOld" href="#rbig.transform.quantile.QuantileTransformerOld">QuantileTransformerOld</a></code></h4>
<ul class="">
<li><code><a title="rbig.transform.quantile.QuantileTransformerOld.extend_support" href="#rbig.transform.quantile.QuantileTransformerOld.extend_support">extend_support</a></code></li>
<li><code><a title="rbig.transform.quantile.QuantileTransformerOld.fit" href="#rbig.transform.quantile.QuantileTransformerOld.fit">fit</a></code></li>
<li><code><a title="rbig.transform.quantile.QuantileTransformerOld.inverse_transform" href="#rbig.transform.quantile.QuantileTransformerOld.inverse_transform">inverse_transform</a></code></li>
<li><code><a title="rbig.transform.quantile.QuantileTransformerOld.transform" href="#rbig.transform.quantile.QuantileTransformerOld.transform">transform</a></code></li>
<li><code><a title="rbig.transform.quantile.QuantileTransformerOld.transform_col" href="#rbig.transform.quantile.QuantileTransformerOld.transform_col">transform_col</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.1</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>